# Full Adder Implementation in Verilog

This project demonstrates the implementation of a full adder circuit in Verilog using different modeling styles. A full adder is a digital circuit that performs addition of three binary digits: two significant bits (A and B) and a carry-in bit (Cin), producing a sum (S) and a carry-out (Cout).

## Project Contents

- **fulladd.v**: Implements the full adder using standard gates and User Defined Primitives (UDPs). It instantiates `sum_udp` and `carry_udp` from `udp.v` for the sum and carry-out logic.
- **fulladd2.v**: Implements the full adder using structural modeling by instantiating basic gates (XOR, AND, OR). This provides a gate-level representation of the full adder.
- **udp.v**: Defines two User Defined Primitives (UDPs):
  - `sum_udp`: Computes the sum output based on a truth table.
  - `carry_udp`: Computes the carry-out output based on a truth table.
- **testfull.v**: A testbench module that automatically verifies the functionality of the full adder. It instantiates `fulladder2` (from `fulladd2.v`), tests all possible input combinations (A, B, Cin), checks outputs against expected values, and displays a pass/fail result (1 for pass, 0 for fail).
- **mysim**: A compiled simulation executable generated by Icarus Verilog (vvp format). This file is used to run the simulation.
- **example.vcd**: A Value Change Dump (VCD) file generated during simulation. It contains waveform data for viewing signal changes over time using tools like GTKWave.
- **README.md**: This file, providing an overview, instructions, and details about the project.

## What is Written

The code includes two main implementations of the full adder:

1. **UDP-Based Implementation (`fulladd.v`)**: Uses custom primitives defined in `udp.v` to model the sum and carry logic directly from truth tables. This is a behavioral approach that abstracts the gate-level details.

2. **Gate-Level Implementation (`fulladd2.v`)**: Uses structural Verilog to instantiate basic logic gates (XOR, AND, OR) to build the full adder circuit. This mirrors the actual hardware implementation.

The testbench (`testfull.v`) exhaustively tests the gate-level implementation by applying all 8 possible input combinations, automatically verifies the outputs against expected values, and displays a pass/fail result. VCD file generation for waveform analysis is commented out by default.

## How to Run the Code

### Prerequisites
- Icarus Verilog (iverilog) installed on your system. If not, download and install it from the official website: http://iverilog.icarus.com/

### Compilation
To compile the Verilog files into a simulation executable:
```
iverilog -o mysim testfull.v fulladd2.v udp.v
```
- This command compiles the testbench (`testfull.v`), the gate-level full adder (`fulladd2.v`), and the UDP definitions (`udp.v`) into an executable named `mysim`.

### Simulation
To run the simulation:
```
vvp mysim
```
- This executes the compiled simulation, which will display the test results in the console, showing a pass/fail result (1 for pass, 0 for fail) after testing all input combinations.

### Viewing Waveforms
To visualize the signal waveforms (VCD generation is commented out by default):
1. Uncomment the VCD dump code in `testfull.v` (the commented initial block).
2. Install GTKWave (a waveform viewer) if not already installed.
3. Run the simulation as above (it generates `example.vcd`).
4. Open the VCD file with GTKWave:
   ```
   gtkwave example.vcd
   ```
- This allows you to inspect the timing and value changes of signals like A, B, Cin, S, and Cout.

### Notes
- The testbench is currently set up to test `fulladder2` (gate-level). To test the UDP-based version, modify `testfull.v` to instantiate `fulladder` from `fulladd.v` instead.
- Ensure all files are in the same directory when compiling.
- The simulation includes delays (#5) between test cases for clarity in waveform viewing.
