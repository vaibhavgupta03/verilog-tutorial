# Multiplexer Implementations in Verilog

This project demonstrates the implementation of multiplexer circuits in Verilog using different modeling styles. A multiplexer (MUX) is a digital circuit that selects one of several input signals and forwards the selected input to a single output line based on select signals.

## Project Contents

- **mux2_1.v**: Implements a 2-to-1 multiplexer using dataflow modeling. It uses an assign statement to select between two inputs based on a single select bit.
- **mux4_1.v**: Implements a 4-to-1 multiplexer using structural modeling by instantiating two 2-to-1 multiplexers. It selects one of four inputs based on two select bits.
- **mux16_1.v**: Implements a 16-to-1 multiplexer using structural modeling by instantiating four 4-to-1 multiplexers. It selects one of sixteen inputs based on four select bits.
- **test_mux.v**: A testbench module that verifies the functionality of the 16-to-1 multiplexer. It instantiates `mux16_1` and tests various select signal combinations with a fixed input vector.
- **mysim**: A compiled simulation executable generated by Icarus Verilog (vvp format). This file is used to run the simulation.
- **mux16_1.vcd**: A Value Change Dump (VCD) file generated during simulation. It contains waveform data for viewing signal changes over time using tools like GTKWave.
- **README.md**: This file, providing an overview, instructions, and details about the project.

## What is Written

The code includes three multiplexer implementations of increasing complexity:

1. **2-to-1 MUX (`mux2_1.v`)**: Uses dataflow modeling with a simple assign statement. This is the most basic form, selecting between two inputs.

2. **4-to-1 MUX (`mux4_1.v`)**: Uses structural modeling to build a 4-input MUX by combining two 2-to-1 MUXes. The first stage selects pairs of inputs, and the second stage selects between those pairs.

3. **16-to-1 MUX (`mux16_1.v`)**: Uses structural modeling to build a 16-input MUX by combining four 4-to-1 MUXes in a hierarchical manner. It demonstrates modular design by reusing smaller MUX components.

The testbench (`test_mux.v`) tests the 16-to-1 MUX by setting a 16-bit input vector and cycling through different select values, monitoring the output. It generates a VCD file for waveform analysis.

## How to Run the Code

### Prerequisites
- Icarus Verilog (iverilog) installed on your system. If not, download and install it from the official website: http://iverilog.icarus.com/

### Compilation
To compile the Verilog files into a simulation executable:
```
iverilog -o mysim test_mux.v mux16_1.v mux4_1.v mux2_1.v
```
- This command compiles the testbench (`test_mux.v`) and all multiplexer modules (`mux16_1.v`, `mux4_1.v`, `mux2_1.v`) into an executable named `mysim`.

### Simulation
To run the simulation:
```
vvp mysim
```
- This executes the compiled simulation, which will display the test results in the console, showing the inputs (I, S) and output (O) for each test case.

### Viewing Waveforms
To visualize the signal waveforms:
1. Install GTKWave (a waveform viewer) if not already installed.
2. Run the simulation as above (it generates `mux16_1.vcd`).
3. Open the VCD file with GTKWave:
   ```
   gtkwave mux16_1.vcd
   ```
- This allows you to inspect the timing and value changes of signals like I, S, and O.

### Notes
- The testbench is set up to test the 16-to-1 MUX. To test smaller MUXes, you can create separate testbenches or modify `test_mux.v`.
- Ensure all files are in the same directory when compiling.
- The simulation includes delays (#5) between test cases for clarity in waveform viewing.
- The input vector in the testbench is set to `16'h2af8` (binary: 0010101011111000), so the output will reflect the bit selected by the select signals.
